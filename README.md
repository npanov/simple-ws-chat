# simple-ws-chat
simple websocket chat backend (python 3.5+, asyncio, websockets)

Требования: Python 3.5, websockets
```
pip install websockets
```

Запуск сервера чата: 
```
python3 server/chat_server.py
```
Сервер слушает по адресу **localhost:8765**

Простой браузерный клиент: **/client/index.html**

## Примеры JSON-запросов:

- {"action": "register", "name": "nik", "pass": "123456"} // **регистрация нового пользователя**
- {"action": "login", "name": "nik", "pass": "123456"} // **подключение к чату (в ответе придет токен сессии)**
- {"action": "send_msg", "name": "nik", "to": ["pik"], "msg": "42", "token": "50d339dc986f4eb7ace33544e75af4f6"} // **отправка сообщения одному или нескольким пользователям, "to" всегда список**
- {"action": "send_msg", "name": "nik", "msg": "42", "token": "50d339dc986f4eb7ace33544e75af4f6"} // **отправка сообщения всем пользователям онлайн**
- {"action": "list_active"} // **вывести список пользователей онлайн (автоизация не требуется)**
- {"action": "logout", "name": "nik", "token": "50d339dc986f4eb7ace33544e75af4f6"} // **выход из чата**

## Особенности реализации:

- Отсутствие хранилища. Зарегистрированные пользователи хранятся пока работает сервер. Для использования БД нужно переопределить функции save_new_user, name_exists, check_credentials. Обращения к хранилищу должны быть неблокирующими.
- Отсутствие классов. Единственный класс - кастомная ошибка с дополнительным полем для сообщения. Контроллеры реализованы как функции с регистрирующим декоратором @action и вызываются из главного цикла по имени, пришедшему из запроса.
- Протокол запросов-ответов JSON регламентирован импровизационно, ему не достает консистентности, но он интуитивно понятен, см. примеры и поле info в ответах со статусом ERROR.
- В качестве примера реализовано несколько проверок (имя занято, имя слишком короткое, адресат в оффлайне и ещё несколько), но только для примера. Тестирования, в т.ч. на секурность не проводилось.

